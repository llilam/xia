# 校园疫情管理系统-毕业设计

### 项目运行

1. 下载项目
2. 进入campus_backend与campus_frontend，执行命令：npm install
3. 创建数据库campus_epidemics，导入sql文件
4. 进入campus_backend/config/config.json，在development配置中修改自己的数据库账号密码
5. 最后一步，同时运行前端与后端
   * campus_backend文件夹，运行命令：node app.js
   * campus_frontend文件夹，运行命令：npm run dev
6. 角色默认账号密码
   * 老师默认账号密码：19999999999------123456
   * 学生默认账号密码：16666666666------123456
   * 工作人员默认账号密码：18888888888------a123456



### **一、项目的所用到的技术栈**

1. 前端：vue+vue-router+vuex+axios+element-ui+element-admin
2. 后端：node+express+mysql+sequelize+sequelize-cli



### 二、项目功能结构图

<img src="./readme_img/0-1.png" width="700"/>

### 三、项目数据库设计

<img src="./readme_img/0-2.png" width="700"/>



### 四、前端开发思路

1. 使用Element-Admin后台管理系统骨架，生成最基本的后台管理系统结构

2. 在路由文件夹router的index.js中配置页面级组件对应的路由访问地址

3. 各个页面级组件编写静态页，这里的静态页使用了Element-UI进行布局，使用Element-UI的原因是比较方便，而且后期做响应式也比较方便

4. 每个页面级组件对应着自身的api接口，使后期维护起来更容易操作，起码想维护时找对应的接口不用一个个找

5. 这里对axios请求进行了二次封装，与api文件夹中的接口配合就不会产生代码冗余，也比较分明，axios请求二次封装单独放在了工具文件夹utils中，里面有三个知识点，配置基准地址、请求拦截器对后端的token进行请求头处理、响应拦截器后期通过自己的业务逻辑而定

6. 前端还使用了js-cookie第三方插件库操作cookie，这里值得注意的是我的状态保持是采用token，分别存储在cookie、vuex、本地存储中，想着后期哪个方便就用哪个

7. router路由文件夹中的总路由也进行了前置路由守卫，如果没有登录的情况下直接进去后台的一系列页面，会先判断本地存储中是否存有token，如果没有token则立马跳转到登录页

8. 前端还涉及了菜单权限的技术点，原本思路是router文件夹中的index.js文件对路由划分静态路由与动态路由，再通过后端请求回来的数据，单独取出用户的权限与动态路由中的路由元属性权限角色进行匹配，如果匹配成功，则对总路由添加角色应有的权限菜单，但是动态路由实现必定出现自动跳转404、空白页、死循环的问题，所以这里采用了另外一种方式，前端根据后端返回的角色，菜单根据角色的权限，进行显示与隐藏解决，虽然写死静态路由也实现了菜单权限，但是对后期的维护肯定是不利的，这个小问题后期还有待解决



### 五、后端开发思路

1. 这里我跟其他后端开发者的思路不太一样，他们会先设计接口再设计前端静态页，这里我会先使用死数据对前端进行排版，前端排版完成后我再判断数据库中需要存放哪些表和字段

2. 其实数据库关系设计好后，我发现了有个点很值得研究，就是登录的角色怎么知道自己是否是密切接触、低风险、高风险、感染? 这里我会想到医院接口，但是好像GitHub上没有相关疫情的医院接口，也感觉不现实，因为这里涉及了太多个人信息，我的解决方法是根据全国疫情接口，判断角色是否达到该区域，从而得出自己是否密切、中高风险等，还有一个想法就是角色自己上报，这里是我的一些思路，可能不太正确。。

3. 表关系大致理解完成后，我利用了mysql的一个热门ORM框架对mysql进行操作，这里的orm框架有很多，我用的是sequelize，为了加速开发，我用了sequelize的生成表结构与字段的一个类似脚手架的工具，叫sequelize-cli

4. 利用sequelize-cli，对需要的数据库表进行初始化，我后端使用的是nodejs，这里会先使用npm init -y初始化整个文件夹，再利用sequelize-cli生成初始化文件，初始化文件夹包括数据库连接配置、迁移文件、模型文件，种子文件等

5. 数据库连接成功后利用sequelize-cli中的npx sequelize-cli db:create创建数据库，再利用model:create命令生成自己所需的数据库表模型，这里生成模型文件以外还会生成迁移文件，迁移文件是模型文件的一个映射文件，模型文件只是单纯显示我创建的表与字段大致内容，迁移文件是对模型文件所创建的内容进行细分，最后再生成seeder种子文件，填充表中的测试数据，最后再利用db:seed:all对测试数据写入表中

6. 创建好所需的数据库表后，开始写后端接口，说白了后端接口也是类似一个路由，我的跨域实现使用了后端的CORS进行跨域，这样前端就可以忽略非同源策略与后端接口进行联调

7. 后端的接口我单独创建了一个文件夹，分类了前端各自模块对应的路由接口，这里我创建了一个总的基准路由地址 /api，后面对接上的都是各自页面模块的一级与一级路由对应的模块增删改查

8. 最后写好的接口利用postman工具进行数据测试，判断接口是否正常连通